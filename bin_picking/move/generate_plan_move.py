#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import copy
import rospy
import math
from geometry_msgs.msg import Vector3, Pose2D, Pose
import moveit_commander
import moveit_msgs.msg
import roslaunch


def generate_plan(group, final_point, number_of_points, q):
    
    # Points for a clean path
    waypoints = []

    # Start with the current pose
    starting_point = Pose()
    starting_point = group.get_current_pose().pose
    waypoints.append(copy.deepcopy(starting_point))

    vector = Vector3()
    vector.x = final_point.x - starting_point.position.x
    vector.y = final_point.y - starting_point.position.y
    vector.z = final_point.z - starting_point.position.z

    length = math.sqrt ( vector.x ** 2.0 + vector.y ** 2.0 + vector.z ** 2.0 )

    point = Pose()
    point.orientation.x = q[0]
    point.orientation.y = q[1]
    point.orientation.z = q[2]
    point.orientation.w = q[3]

    # calculating all the desired points for a safe plan movement
    for n in range(1, number_of_points+1):

        point.position.x = starting_point.position.x + n*(length/3) * vector.x
        point.position.y = starting_point.position.y + n*(length/3) * vector.y
        point.position.z = starting_point.position.z + n*(length/3) * vector.z

        # save all the points
        waypoints.append(copy.deepcopy(point))


    # Final Position
    final_position = Pose()
    final_position.orientation.x = q[0]
    final_position.orientation.y = q[1]
    final_position.orientation.z = q[2]
    final_position.orientation.w = q[3]
    final_position.position.x = final_point.x
    final_position.position.y = final_point.y
    final_position.position.z = final_point.z

    waypoints.append(copy.deepcopy(final_position))

    # We want the cartesian path to be interpolated at 
    # a resolution of 1 cm which is why we will specify 
    # 0.01 as the eef_step in cartesian translation. 
    # We will specify the jump threshold as 0.0, effectively
    # disabling it.
    plan, fraction = group.compute_cartesian_path(
                                waypoints,   # waypoints to follow
                                0.01,        # eef_step 
                                0.0)         # jump_threshold 

    # input the correct timestamp of time_from_start for each point in the waypoints array
    for i in range(len(plan.joint_trajectory.points)-1):
        plan.joint_trajectory.points[i].time_from_start = rospy.Time.now() + plan.joint_trajectory.points[i].time_from_start
    
    print "=== Waiting while RVIZ displays plan..."
    # rospy.sleep(5)

    return plan, fraction

def move_robot(plan, fraction, group):

    print "fraction: ", fraction
    if fraction == 1.0:
        print "planning was successful"
        print "============ IS PLAN OK?? â›” "
        if raw_input("Should I MOVE???? If YES press y!!!!") == 'y' :
            # MOVEMENT
            group.execute(plan)
    else:
        print "planning was not successfull"

def debug_targetspose(uuid,normal,approx_point,eef_position_laser,yaw,pitch):
    roslaunch.configure_logging(uuid)
    launch_objDetect_pointTF = roslaunch.parent.ROSLaunchParent(uuid, ["/home/joana/catkin_ws/src/Bin-picking/bin_picking/launch/objDetection_pointTFtranfer.launch"])
    # Start Launch node objDetection and pointTFtransfer
    launch_objDetect_pointTF.start()

    print "=== Running node objDetection and pointTFtransfer "

    print "Normal: "
    print normal
    print "Approximation Point: "
    print approx_point
    print "End-effector Position for laser sensor measurement: "
    print eef_position_laser
    print "Euler Angles: "
    print "yaw: ", yaw, " pitch: ", pitch
    while raw_input('') != 'a':
        print "Normal: "
        print normal
        print "Approximation Point: "
        print approx_point
        print "End-effector Position for laser sensor measurement: "
        print eef_position_laser
        print "Euler Angles: "
        print "yaw: ", yaw, " pitch: ", pitch
        print "Press A to Confirm Values and Continue!!!!!"

    #Stop Launch node objDetection and pointTFtransfer
    launch_objDetect_pointTF.shutdown()
    # after having stopped both nodes the subscribed topics will be the last published and will be a fixed value


