#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include "sensor_msgs/Image.h"
#include "image_transport/image_transport.h"
#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <opencv2/opencv.hpp>
#include <iostream>
#include <tf_conversions/tf_eigen.h>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <iostream>
#include <string>
#include <vector>
#include <iostream>
#include <math.h>

#include <stdio.h>
#include <stdlib.h>

#include "ros/ros.h"

#include "std_msgs/MultiArrayLayout.h"
#include "std_msgs/MultiArrayDimension.h"

#include	<iostream>
#include	"damas_hsv/Path_Posit.h"
#include	"damas_hsv/conjunto.h"
#include	<iostream>
#include	<sstream>
#include <Eigen/Dense>

#include <iostream>
#include <cstdio>
#include <ctime>

using namespace std;
using namespace cv;
int largest_area=0;
int largest_contour_index=0;
Rect bounding_rect;

int origem_final;
int destino_final;
int remover_final;
int contador_geral=0;

//float primeiro_espaco_x = -0.037;
//float primeiro_espaco_y = 0.111;
//float primeiro_espaco_x = -0.159;
float primeiro_espaco_x = 0.100; //influencia a coluna
float primeiro_espaco_y = 0.0255; //influencia a linha
float d =0.050;//50mm

Eigen::MatrixXf Final(4,4);
Eigen::MatrixXf RoboToCam(4,4);
Eigen::MatrixXf xadrez(8,8);
Eigen::Vector4f FinalMultiplicacao_Pretas;
Eigen::Vector4f FinalMultiplicacao_Brancas;
Eigen::Vector4f FinalMultiplicacao_Vermelhas;
Eigen::Vector4f FinalMultiplicacao_Azuis;	
Eigen::Vector4f centroid;
Eigen::Vector4f Origem_fim_0;
Eigen::Vector4f Origem_fim;
Eigen::Vector4f destino_fim_0;
Eigen::Vector4f destino_fim;
Eigen::Vector4f remover_fim_0;
Eigen::Vector4f remover_fim;
Eigen::MatrixXf InversoFinal(4,4);
RNG rng(12345);
int contador_aruco=0;

    damas_hsv::conjunto pose;





class cloudHandler
{
public:
//====================================================================================================================================================
//****************************************************************************************************************************************************
// Função que é responsavel por invocar tópicos ROS
//****************************************************************************************************************************************************
//====================================================================================================================================================
    cloudHandler()
    {
        sub = nh.subscribe("/camera/rgb/image_color", 1000, &cloudHandler::tratamento, this);
        client = nh.serviceClient<damas_hsv::Path_Posit>("tabuleiro1");
//        pub = nh.advertise<sensor_msgs::Image>("pcl_filtredy_rgb", 1);
        subscriber = nh.subscribe("/camera/rgb/aruco_tracker/transform", 1000, &cloudHandler::PosicaoAruco, this);
        pub_posicao = nh.advertise<damas_hsv::conjunto>("allposition", 1000); // TODO: Uncomment this line
    }

//====================================================================================================================================================
//****************************************************************************************************************************************************
// Função que converte coordenadas métricas em posições do tabuleiro
//****************************************************************************************************************************************************
//====================================================================================================================================================
void ConversaoTabuleiro(Eigen::Vector4f centro,int numero)
    {
    float Linha0;
    float Coluna0;
    
    float linhaaaa;
    float colunaaaa;
    
    int Linha;
    int Coluna;

    
    Linha0 = (centro[0] - primeiro_espaco_x - (d/2));
    linhaaaa = (Linha0 / d);
    Coluna =linhaaaa;
    
    Coluna0 = (centro[1] - primeiro_espaco_y - (d/2));
    colunaaaa = (Coluna0 / d);
    Linha = colunaaaa;

//    cout<<"\ncentro[0]===="<<centro[0];
//    cout<<"\ncentro[1]===="<<centro[1];
////    cout<<"\nLinha0===="<<Linha0;
//cout<<"\nLinhaaaaaaaa===="<<linhaaaa;
//	cout<<"\nColunaaaaaa===="<<colunaaaa;
//	
//    cout<<"\nLinha===="<<Linha;
//	cout<<"\nColuna===="<<Coluna;
	
	switch(Linha)
   {
	   case 0 :
		  	switch(Coluna)
  			{
	  			case 0 :
			  	xadrez(0,0) = numero;
			 	break;
			 	
	  			case 2 :
			  	xadrez(0,2) = numero;
			 	break;
			 	
	  			case 4 :
			  	xadrez(0,4) = numero;
			 	break;
			 	
	  			case 6 :
			  	xadrez(0,6) = numero;
			 	break;
  			}
		break;//Break do case linha 0
	   case 1 :
		  	switch(Coluna)
  			{
	  			case 1 :
			  	xadrez(1,1) = numero;
			 	break;
			 	
	  			case 3 :
			  	xadrez(1,3) = numero;
			 	break;
			 	
	  			case 5 :
			  	xadrez(1,5) = numero;
			 	break;
			 	
	  			case 7 :
			  	xadrez(1,7) = numero;
			 	break;
  			}
		break;//Break do case linha 1
		//
		case 2 :
		  	switch(Coluna)
  			{
	  			case 0 :
			  	xadrez(2,0) = numero;
			 	break;
			 	
	  			case 2 :
			  	xadrez(2,2) = numero;
			 	break;
			 	
	  			case 4 :
			  	xadrez(2,4) = numero;
			 	break;
			 	
	  			case 6 :
			  	xadrez(2,6) = numero;
			 	break;
  			}
		break;//Break do case linha 2
	   case 3 :
		  	switch(Coluna)
  			{
	  			case 1 :
			  	xadrez(3,1) = numero;
			 	break;
			 	
	  			case 3 :
			  	xadrez(3,3) = numero;
			 	break;
			 	
	  			case 5 :
			  	xadrez(3,5) = numero;
			 	break;
			 	
	  			case 7 :
			  	xadrez(3,7) = numero;
			 	break;
  			}
		break;//Break do case linha 3
		//
		case 4 :
		  	switch(Coluna)
  			{
	  			case 0 :
			  	xadrez(4,0) = numero;
			 	break;
			 	
	  			case 2 :
			  	xadrez(4,2) = numero;
			 	break;
			 	
	  			case 4 :
			  	xadrez(4,4) = numero;
			 	break;
			 	
	  			case 6 :
			  	xadrez(4,6) = numero;
			 	break;
  			}
		break;//Break do case linha 4
	   case 5 :
		  	switch(Coluna)
  			{
	  			case 1 :
			  	xadrez(5,1) = numero;
			 	break;
			 	
	  			case 3 :
			  	xadrez(5,3) = numero;
			 	break;
			 	
	  			case 5 :
			  	xadrez(5,5) = numero;
			 	break;
			 	
	  			case 7 :
			  	xadrez(5,7) = numero;
			 	break;
  			}
		break;//Break do case linha 5
		//
		case 6 :
		  	switch(Coluna)
  			{
	  			case 0 :
			  	xadrez(6,0) = numero;
			 	break;
			 	
	  			case 2 :
			  	xadrez(6,2) = numero;
			 	break;
			 	
	  			case 4 :
			  	xadrez(6,4) = numero;
			 	break;
			 	
	  			case 6 :
			  	xadrez(6,6) = numero;
			 	break;
  			}
		break;//Break do case linha 4
	   case 7 :
		  	switch(Coluna)
  			{
	  			case 1 :
			  	xadrez(7,1) = numero;
			 	break;
			 	
	  			case 3 :
			  	xadrez(7,3) = numero;
			 	break;
			 	
	  			case 5 :
			  	xadrez(7,5) = numero;
			 	break;
			 	
	  			case 7 :
			  	xadrez(7,7) = numero;
			 	break;
  			}
		break;//Break do case linha 5
   }
//	cout<<"\nxadrez====\n"<<xadrez;
    	
}//end da funcao



//====================================================================================================================================================
//****************************************************************************************************************************************************
// Função que é invocada pelo tópico da camara RGB
//****************************************************************************************************************************************************
//====================================================================================================================================================
    
    void tratamento(const sensor_msgs::ImageConstPtr& input)
    {
        std::clock_t start;
    double duration;

    start = std::clock();
//////    cout<<"************************************************************************************************************************************";
//////    
//////	double a[10];
//////	double *p = &a[0];
//////	Eigen::MatrixXd(2,5) m;
//////	//Eigen::MatrixXf Matrix(8,8);

//////	Map<Matrix<double,4,4,RowMajor> > M(data);
//////Eigen::Map<Matrix4f> eigenT( cvT.data() ); 
//////	Map<Matrix<double,2,5,RowMajor> >;

//////	for (int i=0; i<2;i++)
//////	for (int j=0; j<5;j++)
//////	m(i,j) = i+j;
//////	cout<<m<<endl;
//////	//Eigen::Map<MatrixXd>(p,2,5) = m;
//////	for (int i=0; i<10; i++)
//////	cout<<a[i]<<" ";
//////	cout<<endl;

//////    cout<<"************************************************************************************************************************************";

        xadrez << 0, 0, 0, 0, 0, 0, 0, 0,
	   			  0, 0, 0, 0, 0, 0, 0, 0,
	 			  0, 0, 0, 0, 0, 0, 0, 0,
	 			  0, 0, 0, 0, 0, 0, 0, 0,
	 			  0, 0, 0, 0, 0, 0, 0, 0,
	 			  0, 0, 0, 0, 0, 0, 0, 0,
	 			  0, 0, 0, 0, 0, 0, 0, 0,
	 			  0, 0, 0, 0, 0, 0, 0, 0;
	 			  
//	 	RoboToCam << 0.0178918, 		0.999898, 	 		-0.00476413,       		0.47331,
//	   			  	 0.999909,  		0.0134594, 			-0.00122077,   	 		0.00101673,
//	 			  	-0.00115652,  		-0.00478013,  		-0.999988,      		0.933004,
//	 			 	 0,         		0,          		0,              		1; 
	 			  
  	 	RoboToCam <<-0.0134651, 		0.999898, 	 		-0.00476413,       		0.47331,
	   			  	 0.999909,  		0.0134594, 			-0.00122077,   	 		0.00101673,
	 			  	-0.00115652,  		-0.00478013,  		-0.999988,      		0.933004,
	 			 	 0,         		0,          		0,              		1; 
	 			  
 			  
 			  
    	cv_bridge::CvImagePtr cv_ptr;
    	
    	try
		{
		  cv_ptr = cv_bridge::toCvCopy(input, sensor_msgs::image_encodings::BGR8);
		}
		catch (cv_bridge::Exception& e)
		{
		  ROS_ERROR("cv_bridge exception: %s", e.what());
		  return;
		}
		
		//**************************************************
		// Imagem convertida de mensagem ROS para imagem em OPENCV
		//**************************************************
		cv::Mat ImageNew = cv_ptr->image;

		// Load input image
		cv::Mat bgr_image = ImageNew;

//		cv::imshow("Imagem rgb recebida", bgr_image);

		cv::waitKey(10);

		cv::Mat orig_image = bgr_image.clone();

		cv::medianBlur(bgr_image, bgr_image, 3);

		cv::waitKey(10);

		//**************************************************
		// Convert input image to HSV
		//**************************************************
		cv::Mat hsv_image;
		cv::cvtColor(bgr_image, hsv_image, cv::COLOR_BGR2HSV);
		int contador_Vermelho=0;
		int contador_bue=0;

		//**************************************************
		// Parâmetros intrinsecos da camera. Essencial para poder passar imagem em pixeis para coordenadas do mundo
		//**************************************************
		float c_x = 319.7238615054187;
		float f_x = 541.8966014693267;
		float c_y = 240.328921274081;
		float f_y = 542.6822021211417; 
		float z_world = 0.809285;
		float x_world;
		float y_world;
		int saltar=0;
		
		
		
		
		
		
		

//******************************************************************************************************
//******************************************************************************************************
//PARA A COR VERMELHA
//******************************************************************************************************
//******************************************************************************************************
		//**************************************************
		// Threshold the HSV image, keep only the red pixels
		//**************************************************

		cv::Mat lower_red_hue_range;
		cv::Mat upper_red_hue_range;
		cv::inRange(hsv_image, cv::Scalar(0, 100, 100), cv::Scalar(10, 255, 255), lower_red_hue_range);
		cv::inRange(hsv_image, cv::Scalar(160, 100, 100), cv::Scalar(180, 255, 255), upper_red_hue_range);

		//**************************************************
		// Threshold the HSV image, keep only the red pixels
		//**************************************************
		// Combine the above two images
		cv::Mat red_hue_image;
		cv::addWeighted(lower_red_hue_range, 1.0, upper_red_hue_range, 1.0, 0.0, red_hue_image);

		//**************************************************
		// Threshold the HSV image, keep only the red pixels
		//**************************************************
		// Show images
//		cv::namedWindow("Threshold lower image", cv::WINDOW_AUTOSIZE);
//		cv::imshow("VERMELHO lower image", lower_red_hue_range);
//		cv::namedWindow("Threshold upper image", cv::WINDOW_AUTOSIZE);
//		cv::imshow("VERMELHO upper image", upper_red_hue_range);
//		cv::namedWindow("Combined threshold images", cv::WINDOW_AUTOSIZE);
//		cv::imshow("Imagem só com pixeis vermelhos", red_hue_image);

//		cv::waitKey(10);
		cv::Mat const structure_elem = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(9, 9));

		//**************************************************
		// Close
		//**************************************************
		cv::Mat close_image;
		cv::Mat dilate_image;	

		//**************************************************
		// Apply morphology operations
		//**************************************************
		erode(red_hue_image, close_image, structure_elem, Point(-1, -1));
		dilate(close_image, dilate_image, structure_elem, Point(-1, -1));

//		cv::imshow("close2", close_image);
//		cv::imshow("Morfologia aplicada à imagem com peças vermelhas", dilate_image);

		Mat canny_output;
		vector<vector<Point> > contours;
		vector<Vec4i> hierarchy;

		findContours( dilate_image, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

		if(contours.size()==0)
		{
			saltar=1;
		}

//**************************************************
// O saltar é para prevenir o programa dar erro em caso de não existir a cor vermelha
//**************************************************
if(saltar==0)
{

		//**************************************************
		/// Get the moments
		//**************************************************
		vector<Moments> mu(contours.size() );
		for( int i = 0; i < contours.size(); i++ )
		{ mu[i] = moments( contours[i], false ); }

		//**************************************************
		///  Get the mass centers:
		//**************************************************
		vector<Point2f> mc( contours.size() );

		//**************************************************
		// Calcula o centro de massa
		// Converte de coordenadas da imagem para coordenadas fisicas
		// Invoca a função para construir o tabuleiro
		//**************************************************
		for(int i = 0; i< contours.size(); i++) {

			mc[i] = Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );
//			       cout<<"\ncenterxx===\n"<<mc[i].x;
//			       cout<<"\ncenteryy===\n"<<mc[i].y;

			contador_Vermelho=contador_Vermelho+1;

			x_world = (mc[i].x - c_x) * z_world / f_x ;
			y_world = (mc[i].y - c_y) * z_world / f_y ;
//					cout<<"\nxxxxx===="<<x_world;
//					cout<<"\nyyyyy===="<<y_world;
			centroid[0]=x_world;
			centroid[1]=y_world;
			centroid[2]=0;
			centroid[3]=1;
			FinalMultiplicacao_Vermelhas=InversoFinal*centroid;
			FinalMultiplicacao_Vermelhas=FinalMultiplicacao_Vermelhas.array().abs();
//					cout<<"\ncenterxxxxx===="<<FinalMultiplicacao_Vermelhas[0];
//					cout<<"\ncenteryyyyy===="<<FinalMultiplicacao_Vermelhas[1];
			ConversaoTabuleiro(FinalMultiplicacao_Vermelhas,4);
		}
		
		//**************************************************
		// Draw contours
		//**************************************************
		Mat drawing = Mat::zeros( dilate_image.size(), CV_8UC3 );
		for( int i = 0; i< contours.size(); i++ )
		{
			Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
			drawContours( drawing, contours, i, color, 2, 8, hierarchy, 0, Point() );
			circle( drawing, mc[i], 4, color, -1, 8, 0 );
		}

		//**************************************************
		/// Show in a window
		//**************************************************
//		namedWindow( "Contours", CV_WINDOW_AUTOSIZE );
//		imshow( "Contours", drawing );
//		cout<<"\n--MOVO-----"<<contador_Vermelho;
//				cv::imshow("Contornos vermelhos", drawing);
		cv::waitKey(10);

}
saltar=0;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		int factores=0;
	
	//******************************************************************************************************
//******************************************************************************************************
//PARA A COR BRANCA
//******************************************************************************************************
//******************************************************************************************************
	//**************************************************
	// Threshold the HSV image, keep only the white pixels
	//**************************************************
	cv::Mat lower_branco_hue_range;
	cv::Mat upper_branco_hue_range;
	cv::inRange(hsv_image, cv::Scalar(0, 0, 200), cv::Scalar(180, 10, 255), lower_branco_hue_range);
	cv::inRange(hsv_image, cv::Scalar(0, 10, 200), cv::Scalar(180, 30, 255), upper_branco_hue_range);

	//**************************************************
	// Threshold the HSV image, keep only the white pixels
	//**************************************************
	// Combine the above two images
	cv::Mat branco_hue_image;
	cv::addWeighted(lower_branco_hue_range, 1.0, upper_branco_hue_range, 1.0, 0.0, branco_hue_image);

	//**************************************************
	// Threshold the HSV image, keep only the red pixels
	//**************************************************
	// Show images
	//////	cv::namedWindow("Threshold lower image", cv::WINDOW_AUTOSIZE);
	////	cv::imshow("branco lower image", lower_branco_hue_range);
	//////	cv::namedWindow("Threshold upper image", cv::WINDOW_AUTOSIZE);
	////	cv::imshow("branco upper image", upper_branco_hue_range);
	//////	cv::namedWindow("Combined threshold images", cv::WINDOW_AUTOSIZE);
//		cv::imshow("Imagem só com pixeis brancos", branco_hue_image);

	cv::waitKey(10);
	cv::Mat const structure_elem_branco = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(9, 9));


	//**************************************************
	// Close
	//**************************************************
	cv::Mat close_image_branco;
	cv::Mat dilate_image_branco;	

	//**************************************************
	// Apply morphology operations
	//**************************************************
	erode(branco_hue_image, close_image_branco, structure_elem_branco, Point(-1, -1));
	dilate(close_image_branco, dilate_image_branco, structure_elem_branco, Point(-1, -1));

	//////////////	cv::imshow("close2", close_image);
//		cv::imshow("Morfologia aplicada à imagem com peças brancas", dilate_image_branco);

	Mat canny_output_branco;
	vector<vector<Point> > contours_branco;
	vector<Vec4i> hierarchy_branco;

	findContours( dilate_image_branco, contours_branco, hierarchy_branco, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
	if(contours_branco.size()==0)
	{
		saltar=1;
	}
//**************************************************
// O saltar é para prevenir o programa dar erro em caso de não existir a cor branca
//**************************************************
	if(saltar==0)
	{
		//**************************************************
		/// Get the moments
		//**************************************************
		vector<Moments> mu_branco(contours_branco.size() );
		for( int i = 0; i < contours_branco.size(); i++ )
		{ mu_branco[i] = moments( contours_branco[i], false ); }

		//**************************************************
		///  Get the mass centers:
		//**************************************************
		vector<Point2f> mc_branco( contours_branco.size() );

		//**************************************************
		// Calcula o centro de massa
		// Converte de coordenadas da imagem para coordenadas fisicas
		// Invoca a função para construir o tabuleiro
		//**************************************************
		for(int i = 0; i< contours_branco.size(); i++) {
			//**************************************************
			// Calcula o factor de forma para diferenciar as diferentes formas que são recolhidas
			//**************************************************
			double a=contourArea( contours_branco[i],false);  //  Find the area of contour
			double len1 = arcLength(contours_branco[i], true);
			double ff1=(4*M_PI*a);
			double ff=((ff1)/(sqrt(len1)));

			if(ff >= 1.20 && ff <= 0.90)
			factores=factores+1;

			//		cout<<"\nAREA===="<<a;
			//		cout<<"\nPERIMETRO===="<<len1;
			//		cout<<"\nFF===="<<ff;


			mc_branco[i] = Point2f( mu_branco[i].m10/mu_branco[i].m00 , mu_branco[i].m01/mu_branco[i].m00 );
			//       cout<<"\ncenterxx===\n"<<mc_branco[i].x;
			//       cout<<"\ncenteryy===\n"<<mc_branco[i].y;

			contador_Vermelho=contador_Vermelho+1;

			x_world = (mc_branco[i].x - c_x) * z_world / f_x ;
			y_world = (mc_branco[i].y - c_y) * z_world / f_y ;

			centroid[0]=x_world;
			centroid[1]=y_world;
			centroid[2]=0;
			centroid[3]=1;
			FinalMultiplicacao_Vermelhas=InversoFinal*centroid;
			//		cout<<"\ncenterxxxxx===="<<FinalMultiplicacao_Vermelhas[0];
			//		cout<<"\ncenteryyyyy===="<<FinalMultiplicacao_Vermelhas[1];
			FinalMultiplicacao_Vermelhas=FinalMultiplicacao_Vermelhas.array().abs();
			ConversaoTabuleiro(FinalMultiplicacao_Vermelhas,1);



		}

		//**************************************************
		// Draw contours
		//**************************************************
		Mat drawing_branco = Mat::zeros( dilate_image.size(), CV_8UC3 );
		for( int i = 0; i< contours_branco.size(); i++ )
		{
			Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
			drawContours( drawing_branco, contours_branco, i, color, 2, 8, hierarchy_branco, 0, Point() );
			circle( drawing_branco, mc_branco[i], 4, color, -1, 8, 0 );
		}



		//**************************************************
		/// Show in a window
		//**************************************************
		//  namedWindow( "Contours", CV_WINDOW_AUTOSIZE );
		//  imshow( "branco", drawing_branco );
		//	cout<<"\n--MOVO-----"<<contador_Vermelho;
//				cv::imshow("Contornos brancos", drawing_branco);
		cv::waitKey(10);
	}// fim do saltar das brancas
	//cout<<"\nFACTORES===="<<factores;
	saltar=0;	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
//******************************************************************************************************
//******************************************************************************************************
//AZUL
//******************************************************************************************************
//******************************************************************************************************
	//**************************************************
	// Threshold the HSV image, keep only the red pixels
	//**************************************************
	cv::Mat lower_bue_hue_range;
	cv::Mat upper_bue_hue_range;
	cv::inRange(hsv_image, cv::Scalar(75, 100, 70), cv::Scalar(120, 255, 255), lower_bue_hue_range);
	cv::inRange(hsv_image, cv::Scalar(120, 100, 70), cv::Scalar(150, 255, 255), upper_bue_hue_range);

	//**************************************************
	// Threshold the HSV image, keep only the blue pixels
	//**************************************************
	// Combine the above two images
	cv::Mat bue_hue_image;
	cv::addWeighted(lower_bue_hue_range, 1.0, upper_bue_hue_range, 1.0, 0.0, bue_hue_image);

	//**************************************************
 	// Show images
	//**************************************************
	//	cv::namedWindow("Threshold lower image", cv::WINDOW_AUTOSIZE);
//	cv::imshow("AZUL lower image", lower_bue_hue_range);
	//	cv::namedWindow("Threshold upper image", cv::WINDOW_AUTOSIZE);
//	cv::imshow("AZUL upper image", upper_bue_hue_range);
	//	cv::namedWindow("Combined threshold images", cv::WINDOW_AUTOSIZE);
//	cv::imshow("Imagem só com pixeis azuis", bue_hue_image);

	cv::waitKey(10);
	cv::Mat const structure_elem_bue = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(9, 9));


	//**************************************************
	// Close
	//**************************************************
	cv::Mat close_image_bue;
	cv::Mat dilate_image_bue;	

	//**************************************************
	// Apply morphology operations
	//**************************************************
	erode(bue_hue_image, close_image_bue, structure_elem_bue, Point(-1, -1));
	dilate(close_image_bue, dilate_image_bue, structure_elem_bue, Point(-1, -1));

	//////////////	cv::imshow("close2", close_image);
//		cv::imshow("Morfologia aplicada à imagem com peças azuis", dilate_image_bue);

	Mat canny_output_bue;
	vector<vector<Point> > contours_bue;
	vector<Vec4i> hierarchy_bue;

	findContours( dilate_image_bue, contours_bue, hierarchy_bue, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

	if(contours_bue.size()==0)
	{
		saltar=1;
	}
	
//**************************************************
// O saltar é para prevenir o programa dar erro em caso de não existir a cor azul
//**************************************************
	if(saltar==0)
	{
	
		//**************************************************
		/// Get the moments
		//**************************************************
		vector<Moments> mu_bue(contours_bue.size() );

		for( int i = 0; i < contours_bue.size(); i++ )
		{ mu_bue[i] = moments( contours_bue[i], false ); }

		//**************************************************
		///  Get the mass centers:
		//**************************************************
		vector<Point2f> mc_bue( contours_bue.size() );

		//**************************************************
		// Calcula o centro de massa
		// Converte de coordenadas da imagem para coordenadas fisicas
		// Invoca a função para construir o tabuleiro
		//**************************************************
		for(int i = 0; i< contours_bue.size(); i++) {

			mc_bue[i] = Point2f( mu_bue[i].m10/mu_bue[i].m00 , mu_bue[i].m01/mu_bue[i].m00 );
			//       cout<<"\ncenterxx===\n"<<mc_bue[i].x;
			//       cout<<"\ncenteryy===\n"<<mc_bue[i].y;

			contador_Vermelho=contador_Vermelho+1;

			x_world = (mc_bue[i].x - c_x) * z_world / f_x ;
			y_world = (mc_bue[i].y - c_y) * z_world / f_y ;

			centroid[0]=x_world;
			centroid[1]=y_world;
			centroid[2]=0;
			centroid[3]=1;
			FinalMultiplicacao_Vermelhas=InversoFinal*centroid;
			//		cout<<"\ncenterxxxxx===="<<FinalMultiplicacao_Vermelhas[0];
			//		cout<<"\ncenteryyyyy===="<<FinalMultiplicacao_Vermelhas[1];
			FinalMultiplicacao_Vermelhas=FinalMultiplicacao_Vermelhas.array().abs();
			ConversaoTabuleiro(FinalMultiplicacao_Vermelhas,3);
		}

		//**************************************************
		// Draw contours
		//**************************************************
		Mat drawing_bue = Mat::zeros( dilate_image.size(), CV_8UC3 );
		for( int i = 0; i< contours_bue.size(); i++ )
		{
			Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
			drawContours( drawing_bue, contours_bue, i, color, 2, 8, hierarchy_bue, 0, Point() );
			circle( drawing_bue, mc_bue[i], 4, color, -1, 8, 0 );
		}

		//**************************************************
		/// Show in a window
		//**************************************************
		//  namedWindow( "Contours", CV_WINDOW_AUTOSIZE );
//		imshow( "Contours AZUL", drawing_bue );
		//		cout<<"\n--MOVO-----"<<contador_Vermelho;
//				cv::imshow("Contornos azuis", drawing_bue);
		cv::waitKey(10);
	}
	saltar=0;	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
//******************************************************************************************************
//******************************************************************************************************
//PARA A COR VERDE
//******************************************************************************************************
//******************************************************************************************************
	//**************************************************
	// Threshold the HSV image, keep only the red pixels
	//**************************************************
	cv::Mat lower_verde_hue_range;
	cv::Mat upper_verde_hue_range;
	cv::inRange(hsv_image, cv::Scalar(30, 100, 90), cv::Scalar(50, 255, 255), lower_verde_hue_range);
	cv::inRange(hsv_image, cv::Scalar(50, 100, 90), cv::Scalar(65, 255, 255), upper_verde_hue_range);

	//**************************************************
	// Threshold the HSV image, keep only the red pixels
	//**************************************************
	// Combine the above two images
	cv::Mat verde_hue_image;
	cv::addWeighted(lower_verde_hue_range, 1.0, upper_verde_hue_range, 1.0, 0.0, verde_hue_image);

	//**************************************************
	// Threshold the HSV image, keep only the red pixels
	//**************************************************
	// Show images
	//	cv::namedWindow("Threshold lower image", cv::WINDOW_AUTOSIZE);
//	cv::imshow("verde lower image", lower_verde_hue_range);
	//	cv::namedWindow("Threshold upper image", cv::WINDOW_AUTOSIZE);
//	cv::imshow("verde upper image", upper_verde_hue_range);
	//	cv::namedWindow("Combined threshold images", cv::WINDOW_AUTOSIZE);
//	cv::imshow("Imagem só com pixeis verdes", verde_hue_image);

	cv::waitKey(10);
	cv::Mat const structure_elem_verde = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(9, 9));


	//**************************************************
	// Close
	//**************************************************
	cv::Mat close_image_verde;
	cv::Mat dilate_image_verde;	

	//**************************************************
	// Apply morphology operations
	//**************************************************
	erode(verde_hue_image, close_image_verde, structure_elem_verde, Point(-1, -1));
	dilate(close_image_verde, dilate_image_verde, structure_elem_verde, Point(-1, -1));

	//////////////	cv::imshow("close2", close_image);
//		cv::imshow("Morfologia aplicada à imagem com peças verdes", dilate_image_verde);

	Mat canny_output_verde;
	vector<vector<Point> > contours_verde;
	vector<Vec4i> hierarchy_verde;

	findContours( dilate_image_verde, contours_verde, hierarchy_verde, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

	if(contours_verde.size()==0)
	{
		saltar=1;
	}

//**************************************************
// O saltar é para prevenir o programa dar erro em caso de não existir a cor VERDE
//**************************************************
	if(saltar==0)
	{
		//**************************************************
		/// Get the moments
		//**************************************************
		vector<Moments> mu_verde(contours_verde.size() );
		for( int i = 0; i < contours_verde.size(); i++ )
		{ mu_verde[i] = moments( contours_verde[i], false ); }

		//**************************************************
		///  Get the mass centers:
		//**************************************************
		vector<Point2f> mc_verde( contours_verde.size() );

		//**************************************************
		// Calcula o centro de massa
		// Converte de coordenadas da imagem para coordenadas fisicas
		// Invoca a função para construir o tabuleiro
		//**************************************************
		for(int i = 0; i< contours_verde.size(); i++) {

			mc_verde[i] = Point2f( mu_verde[i].m10/mu_verde[i].m00 , mu_verde[i].m01/mu_verde[i].m00 );
//			cout<<"\ncenterx_imagem==="<<mc_verde[i].x;
//			cout<<"\ncentery_imagem==="<<mc_verde[i].y;

			contador_Vermelho=contador_Vermelho+1;

			x_world = (mc_verde[i].x - c_x) * z_world / f_x ;
			y_world = (mc_verde[i].y - c_y) * z_world / f_y ;

//			cout<<"\nx_camera==="<<x_world;
//			cout<<"\ny_camera==="<<y_world;
usleep(1);
			centroid[0]=x_world;
			centroid[1]=y_world;
			centroid[2]=0;
			centroid[3]=1;
			FinalMultiplicacao_Vermelhas=InversoFinal*centroid;
			FinalMultiplicacao_Vermelhas=FinalMultiplicacao_Vermelhas.array().abs();
//			cout<<"\ncenterx_aruco===="<<FinalMultiplicacao_Vermelhas[0];
//			cout<<"\ncentery_aruco===="<<FinalMultiplicacao_Vermelhas[1];
			ConversaoTabuleiro(FinalMultiplicacao_Vermelhas,2);


		}
		
		//**************************************************
		// Draw contours
		//**************************************************
		Mat drawing_verde = Mat::zeros( dilate_image.size(), CV_8UC3 );
		for( int i = 0; i< contours_verde.size(); i++ )
		{
			Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
			drawContours( drawing_verde, contours_verde, i, color, 2, 8, hierarchy_verde, 0, Point() );
			circle( drawing_verde, mc_verde[i], 4, color, -1, 8, 0 );
		}

		//**************************************************
		/// Show in a window
		//**************************************************
		//  namedWindow( "Contours", CV_WINDOW_AUTOSIZE );
//		imshow( "Contours VERDE", drawing_verde );
		//		cout<<"\n--MOVO-----"<<contador_Vermelho;
//				cv::imshow("Contornos verdes", drawing_verde);
		cv::waitKey(10);
	}
	saltar=0;		
//	sleep(1);
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	

	
	//sleep(4);
		
		
		
		
//******************************************************************************************************
//******************************************************************************************************
//Acabou a parte da separação da cor, Agora vamos passar para o algoritmo
//******************************************************************************************************
//******************************************************************************************************

//			xadrez(5,1)=1;
//			xadrez(5,3)=1;
//			xadrez(5,5)=1;
//			xadrez(5,7)=1;

//			xadrez(6,0)=1;
//			xadrez(6,2)=1;
//			xadrez(6,4)=1;
//			xadrez(6,6)=1;

//			xadrez(7,1)=1;
//			xadrez(7,3)=1;
//			xadrez(7,5)=1;
//			xadrez(7,7)=1;
//			
//			xadrez(0,0)=2;
//			xadrez(0,2)=2;
//			xadrez(0,4)=2;
//			xadrez(0,6)=2;

//			xadrez(1,1)=2;
//			xadrez(1,3)=2;
//			xadrez(1,5)=2;
//			xadrez(1,7)=2;

//			xadrez(2,0)=2;
//			xadrez(2,2)=2;
//			xadrez(2,4)=2;
//			xadrez(2,6)=2;
			////////////////////////////////////////////////////////
//			xadrez(5,1)=1;
//			xadrez(4,0)=1;
//			xadrez(4,2)=1;
////			xadrez(5,7)=1;

////			xadrez(6,0)=1;
////			xadrez(6,2)=1;
////			xadrez(6,4)=1;
////			xadrez(6,6)=1;

//			xadrez(7,1)=1;
//			xadrez(7,3)=1;
////			xadrez(7,5)=1;
//			xadrez(7,7)=4;
//			
//			xadrez(0,0)=2;
//			xadrez(0,2)=2;
//			xadrez(0,4)=2;
//			xadrez(0,6)=3;

////			xadrez(1,1)=2;
////			xadrez(1,3)=2;
////			xadrez(1,5)=2;
////			xadrez(1,7)=2;

//			xadrez(2,0)=2;
////			xadrez(2,2)=2;
//			xadrez(2,4)=2;
//			xadrez(4,4)=2;
//			xadrez(3,7)=1;
			
//			cout<<"\nDisposição instantânea do tabuleiro =\n"<<xadrez;	
damas_hsv::Path_Posit srv;

	//**************************************************
	/// Espelhar vertical a matriz recolhida do mundo exterior. É necessário fazer isto porque o algoritmo foi construido com o espelho vertical do tabuleiro.
	//**************************************************

	int flip[8][8];

   for(int x=0;x<8;x++)  // loop 3 times for three lines
    {
        for(int y=0;y<8;y++)  // loop for the three elements on the line
        {
        	flip[x][y]=xadrez(x,7-y);
        }
//    cout<<endl;  // when the inner loop is done, go to a new line
    }
    
//    cout<<"\nNova disposição do tabuleiro =\n";
//      for(int x=0;x<8;x++)  // loop 3 times for three lines
//    {
//        for(int y=0;y<8;y++)  // loop for the three elements on the line
//        {
//            cout<<flip[x][y]<<" ";  // display the current element out of the array
//        }
//    cout<<endl;  // when the inner loop is done, go to a new line
//    }

contador_geral=contador_geral+1;
//if (contador_geral<=4) //4
//{

	//**************************************************
	/// Enviar para o servidor
	//**************************************************
	srv.request.linha0 = {flip[0][0],flip[0][1],flip[0][2],flip[0][3],flip[0][4],flip[0][5],flip[0][6],flip[0][7]};
	srv.request.linha1 = {flip[1][0],flip[1][1],flip[1][2],flip[1][3],flip[1][4],flip[1][5],flip[1][6],flip[1][7]};
	srv.request.linha2 = {flip[2][0],flip[2][1],flip[2][2],flip[2][3],flip[2][4],flip[2][5],flip[2][6],flip[2][7]};
	srv.request.linha3 = {flip[3][0],flip[3][1],flip[3][2],flip[3][3],flip[3][4],flip[3][5],flip[3][6],flip[3][7]};
	srv.request.linha4 = {flip[4][0],flip[4][1],flip[4][2],flip[4][3],flip[4][4],flip[4][5],flip[4][6],flip[4][7]};
	srv.request.linha5 = {flip[5][0],flip[5][1],flip[5][2],flip[5][3],flip[5][4],flip[5][5],flip[5][6],flip[5][7]};
	srv.request.linha6 = {flip[6][0],flip[6][1],flip[6][2],flip[6][3],flip[6][4],flip[6][5],flip[6][6],flip[6][7]};
	srv.request.linha7 = {flip[7][0],flip[7][1],flip[7][2],flip[7][3],flip[7][4],flip[7][5],flip[7][6],flip[7][7]};
	
	
//	sleep(5);
	
	int origem_2 ;
	int origem_22 ;
	int destino_2 ;
	int destino_22 ;
	int remover_2 ;
	int remover_22 ;
	
	int origem_3;
	int destino_3;
	int remover_3;
	
	float Origem_fim_x;
	float Origem_fim_y;
	
	//**************************************************
	/// Receber mensagem do servidor e guarda-la
	//**************************************************
	if (client.call(srv))
	{
//			ROS_INFO("Client [%li,%li], enviou [%i;%i;%i]",srv.request.linha0[3],srv.request.linha0[7],srv.response.origem,srv.response.destino,srv.response.remover);
			int origem_1 = srv.response.origem;
			int destino_1 = srv.response.destino;
			int remover_1 = srv.response.remover;
			
//			cout<<"\nMensagem recebida do servidor=\n";
//			cout<<"\nPosição Origem ="<<origem_1;	
//			cout<<"\nPosição Destino ="<<destino_1;	
//			cout<<"\nPosição Remover ="<<remover_1;	
//			cout<<"\n";

			origem_2 = origem_1 % 10;	//2º digito do numero de origem
			origem_22 = origem_1 / 10 % 10; //1º digito do numero de origem
			destino_2 = destino_1 % 10;	//2º digito do numero de destino
			destino_22 = destino_1 / 10 % 10; //1º digito do numero de destino
			remover_2 = remover_1 % 10;	//2º digito do numero de remover
			remover_22 = remover_1 / 10 % 10; //1º digito do numero de remover

			//**************************************************
			/// Desfazer a espelhagem vertical.
			//**************************************************
			switch(origem_2)
		   {
			 case 0 :
		     origem_3 = 7;
		     break;
		     
	 	     case 1 :
		     origem_3 = 6;
		     break;
		     
	 	     case 2 :
		     origem_3 = 5;
		     break;
		 
	 	     case 3 :
		     origem_3 = 4;
		     break;
		     
	 	     case 4 :
		     origem_3 = 3;
		     break;
		     
	 	     case 5 :
		     origem_3 = 2;
		     break;
		     
	 	     case 6 :
		     origem_3 = 1;
		     break;
		     
		     case 7 :
		     origem_3 = 0;
		     break;
		     }
		     origem_final = origem_22 * 10 + origem_3;
	/////////////////////////////////////////////
		     switch(destino_2)
		   {
			 case 0 :
		     destino_3 = 7;
		     break;
		     
	 	     case 1 :
		     destino_3 = 6;
		     break;
		     
	 	     case 2 :
		     destino_3 = 5;
		     break;
		 
	 	     case 3 :
		     destino_3 = 4;
		     break;
		     
	 	     case 4 :
		     destino_3 = 3;
		     break;
		     
	 	     case 5 :
		     destino_3 = 2;
		     break;
		     
	 	     case 6 :
		     destino_3 = 1;
		     break;
		     
		     case 7 :
		     destino_3 = 0;
		     break;
		     }
		     destino_final = destino_22 * 10 + destino_3;
	///////////////////////////////////////////// 

		if(remover_1 >= 0)
		{
//		cout<<"\nentrei aqui ##########################################################################\n";
		 		switch(remover_2)
			   {
				 case 0 :
				 remover_3 = 7;
				 break;
				 
		 	     case 1 :
				 remover_3 = 6;
				 break;
				 
		 	     case 2 :
				 remover_3 = 5;
				 break;
			 
		 	     case 3 :
				 remover_3 = 4;
				 break;
				 
		 	     case 4 :
				 remover_3 = 3;
				 break;
				 
		 	     case 5 :
				 remover_3 = 2;
				 break;
				 
		 	     case 6 :
				 remover_3 = 1;
				 break;
				 
				 case 7 :
				 remover_3 = 0;
				 break;
			 }
				 remover_final = remover_22 * 10 + remover_3;
		}
	///////////////////////////////////////////
//	cout<<"\nMensagem convertida=";
//			cout<<"\nPosição Origem ="<<origem_final;	
//			cout<<"\nPosição Destino ="<<destino_final;	
//			cout<<"\nPosição Remover ="<<remover_final;	
//			cout << "origem_final;====" << origem_final;
//			cout << "destino_final;====" << destino_final;
		
		
		//**************************************************
		// Converter posições do tabuleiro em posições cartesianas
		//**************************************************
		
//////		float x_origem_1 = (origem_22*d)+(primeiro_espaco_x)+ (d/2);//Coluna0
//////		float y_origem_1 = (origem_3*d)+(primeiro_espaco_y)+ (d/2);//Linha
//		cout << "origem_22;====" << origem_22;
//		cout << "origem_3;====" << origem_3;
	    float x_origem_1 =  (primeiro_espaco_x) + (origem_3*d) + (d/2);	//Coluna0
	    float y_origem_1 =  (primeiro_espaco_y) + (origem_22*d) + (d/2);	//Linha
	    
	    float x_destino_1 =  (primeiro_espaco_x) + (destino_3*d) + (d/2);	//Coluna0
	    float y_destino_1 =  (primeiro_espaco_y) + (destino_22*d) + (d/2);	//Linha
	    
	    float x_remover_1;
	    float y_remover_1;
	    if(remover_1 >= 0)
		{
		
	    x_remover_1 =  (primeiro_espaco_x) + (remover_3*d) + (d/2);	//Coluna0
	    y_remover_1 =  (primeiro_espaco_y) + (remover_22*d) + (d/2);	//Linha
		
		}
//	cout << "\nCoordenada_X_origem;====" << x_origem_1;
//	cout << "\nCoordenada_Y_origem;====" << y_origem_1;
		
//------------------------------------------------------------------
		Origem_fim_0[0]=-x_origem_1;
		Origem_fim_0[1]=y_origem_1;
		Origem_fim_0[2]=0;
		Origem_fim_0[3]=1;
		//**************************************************
		// Converter coordenadas do referencial do ARUCO para o referencial do ROBO
		//**************************************************
		Eigen::Vector4f Origem_fim_01;
		Eigen::Vector4f Origem_fim_02;
	
		Origem_fim_01 = Final*Origem_fim_0;
		Origem_fim = RoboToCam*Origem_fim_01;
		
//		cout << "\nTODAS;====" << Origem_fim;
//------------------------------------------------------------------
//------------------------------------------------------------------
		destino_fim_0[0]=-x_destino_1;
		destino_fim_0[1]=y_destino_1;
		destino_fim_0[2]=0;
		destino_fim_0[3]=1;
		//**************************************************
		// Converter coordenadas do referencial do ARUCO para o referencial do ROBO
		//**************************************************
		Eigen::Vector4f destino_fim_01;
		Eigen::Vector4f destino_fim_02;
	
		destino_fim_01 = Final*destino_fim_0;
		destino_fim = RoboToCam*destino_fim_01;
		
//		cout << "\nTODAS;====" << destino_fim;
//------------------------------------------------------------------
//------------------------------------------------------------------
//------------------------------------------------------------------
		Eigen::Vector4f remover_fim_01;
		Eigen::Vector4f remover_fim_02;
		
	if(remover_1 >= 0)
		{
			remover_fim_0[0]=-x_remover_1;
			remover_fim_0[1]=y_remover_1;
			remover_fim_0[2]=0;
			remover_fim_0[3]=1;
			//**************************************************
			// Converter coordenadas do referencial do ARUCO para o referencial do ROBO
			//**************************************************

	
			remover_fim_01 = Final*remover_fim_0;
			remover_fim = RoboToCam*remover_fim_01;
		}
//		cout << "\nTODAS;====" << destino_fim;
//------------------------------------------------------------------
	//		Origem_fim_0.array().abs();
	//	Origem_fim_0[1]=y_origem_1;
	//	Origem_fim_0[2]=0.10;
	//	Origem_fim_0[3]=1;


	
	//	Origem_fim_02 = RoboToCam*Origem_fim_0;
	
	//	cout << "\nMultiplicar Por camera;====" << Origem_fim_01;
		
	//		sleep(2);

	
	//	cout << "\nMultiplicar Por robo;====" << Origem_fim_02;
	
//		cout << "\n*******************************************************====";
	//}
	//else
	//{
	//		ROS_ERROR("Failed to call service");
	//		exit(1);				
	//}

	


		
		pose.origem.x = Origem_fim(0);
		pose.origem.y = Origem_fim(1);
		pose.origem.z = 0;
		
		pose.destino.x = destino_fim(0);
		pose.destino.y = destino_fim(1);
		pose.destino.z = 0;
		
		pose.remover.x = 99;
		pose.remover.y = 99;
		pose.remover.z = 0;
		
		if(remover_1 >= 0)
		{
//			cout<<"\nentrei aqui 2222222222222222 ##########################################################################\n";
			pose.remover.x = remover_fim(0);
			pose.remover.y = remover_fim(1);
			pose.remover.z = 0;
		}
		
	//    pose.destino = destino_final;
	//    pose.remover = remover_final;
//	    sleep(10);



	}//END DO CLIENT CALL
//}//END DO IF DO CONTADOR

	pub_posicao.publish(pose);

	 	duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC;

    std::cout<<"printf: "<< duration <<'\n';
	
    }
        
    
    
    
    
    
    
    
//******************************************************************************************************
//******************************************************************************************************
//Calcular a transformação do aruco para a camera
//******************************************************************************************************
//******************************************************************************************************
void PosicaoAruco(const geometry_msgs::TransformStamped & msgTf)
{

	contador_aruco=contador_aruco+1;
//	if(contador_aruco<3)
//	{
		//		ROS_INFO("\n \n NOVO NOVO NOVO NOVO NOVO NOVO NOVO!!!! \n");
		//	 	ROS_INFO("Sequence ID:[%d]",msgTf.header.seq);
		//		ROS_INFO("msg time:[%d,%d]",msgTf.header.stamp.sec,msgTf.header.stamp.nsec);
		//		ROS_INFO("tf[x=%f,y=%f,z=%f]",msgTf.transform.translation.x,msgTf.transform.translation.y,msgTf.transform.translation.z);
		//		ROS_INFO("orientation[x=%f,y=%f,z=%f,w=%f]",msgTf.transform.rotation.x,msgTf.transform.rotation.y,msgTf.transform.rotation.z,msgTf.transform.rotation.w);

		float Transx = msgTf.transform.translation.x;

		//		std::cout << "\nInformação proveniente em Quaternion. Passar de Quaternion para RPY : \n";

		//**************************************************
		// Utilizar a mensagem que vem do tópico e converter de QUATERNIONS para a MATRIX de rotação
		//**************************************************
		tf::Quaternion q(msgTf.transform.rotation.x, msgTf.transform.rotation.y, msgTf.transform.rotation.z, msgTf.transform.rotation.w);
		tf::Matrix3x3 m(q);

		//		toRotationMatrix
		//std::cout<<"\ngetColumn(0)==="<<*m.getColumn(0);
		//std::cout<<"\ngetColumn(1)==="<<*m.getColumn(1);
		//std::cout<<"\ngetColumn(2)==="<<*m.getColumn(2);
		//std::cout<<"\ngetColumn(3)==="<<*m.getColumn(3);
		//std::cout<<"\ngetColumn(4)==="<<*m.getColumn(4);
		//std::cout<<"\ngetColumn(5)==="<<*m.getColumn(5);
		//std::cout<<"\ngetColumn(6)==="<<*m.getColumn(6);
		//std::cout<<"\ngetColumn(7)==="<<*m.getColumn(7);
		//std::cout<<"\ngetColumn(8)==="<<*m.getColumn(8);
		//std::cout<<"\ngetColumn(9)==="<<*m.getColumn(9);
		//std::cout<<"\ngetColumn(10)==="<<*m.getColumn(10);
		//std::cout<<"\ngetColumn(11)==="<<*m.getColumn(11);
		////std::cout<<"\ngetColumn(12)==="<<*m.getColumn(12);
		//std::cout<<"\ngetRow(0)==="<<*m.getRow(0);
		//std::cout<<"\ngetRow(1)==="<<*m.getRow(1);
		//std::cout<<"\ngetRow(2)==="<<*m.getRow(2);
		//std::cout<<"\ngetRow(3)==="<<*m.getRow(3);
		//std::cout<<"\ngetRow(4)==="<<*m.getRow(4);
		//std::cout<<"\ngetRow(5)==="<<*m.getRow(5);
		//std::cout<<"\ngetRow(6)==="<<*m.getRow(6);
		double roll, pitch, yaw;
		m.getRPY(roll, pitch, yaw);

		//		std::cout << "\nRoll: " << roll << ", Pitch: " << pitch << ", Yaw: " << yaw << std::endl;

		//**************************************************
		// Utilizar a mensagem que vem do tópico e converter para angulos de euler
		//**************************************************
		Eigen::AngleAxisd rollAngle(roll, Eigen::Vector3d::UnitX());
		Eigen::AngleAxisd pitchAngle(pitch, Eigen::Vector3d::UnitY());
		Eigen::AngleAxisd yawAngle(yaw, Eigen::Vector3d::UnitZ());

		Eigen::Quaterniond q1 = yawAngle * pitchAngle * rollAngle;
		
		//**************************************************
		// Construção da matriz de rotação 3x3
		//**************************************************
		Eigen::Matrix3d rotationMatrix = q1.matrix();
//				std::cout << "\n Passar informação de RPY para matriz de rotação 3x3  : \n";

//			std::cout << "\n rotationMatrix==\n" << rotationMatrix;
		float rotationMatrix1[3][3];
		float rodaz[3][3];
		float rodax[3][3];
		float final11[3][3];
		float final22[3][3];

		//**************************************************
		// Passar a matriz de rotação da biblioteca eigen para STD
		//**************************************************
		rotationMatrix1[0][0]=rotationMatrix(0,0);
		rotationMatrix1[0][1]=rotationMatrix(0,1);
		rotationMatrix1[0][2]=rotationMatrix(0,2);

		rotationMatrix1[1][0]=rotationMatrix(1,0);
		rotationMatrix1[1][1]=rotationMatrix(1,1);
		rotationMatrix1[1][2]=rotationMatrix(1,2);

		rotationMatrix1[2][0]=rotationMatrix(2,0);
		rotationMatrix1[2][1]=rotationMatrix(2,1);
		rotationMatrix1[2][2]=rotationMatrix(2,2);
		//			std::cout << "\n rotationMatrix1==\n";

		//   for(int x=0;x<3;x++)  // loop 3 times for three lines
		//    {
		//        for(int y=0;y<3;y++)  // loop for the three elements on the line
		//        {
		//            cout<<rotationMatrix1[x][y];  // display the current element out of the array
		//        }
		//    cout<<endl;  // when the inner loop is done, go to a new line
		//    }

		//	 Eigen::MatrixXf rodaz(3,3);
		//	 rodaz << -1,0,0,
		//	 		  0,-1,0,
		//	 		  0,0,1;
		rodaz[0][0]=-1;
		rodaz[0][1]=0;
		rodaz[0][2]=0;

		rodaz[1][0]=0;
		rodaz[1][1]=-1;
		rodaz[1][2]=0;

		rodaz[2][0]=0;
		rodaz[2][1]=0;
		rodaz[2][2]=1;
/////////////////////////////
		rodax[0][0]=1;
		rodax[0][1]=0;
		rodax[0][2]=0;

		rodax[1][0]=0;
		rodax[1][1]=0;
		rodax[1][2]=-1;

		rodax[2][0]=0;
		rodax[2][1]=1;
		rodax[2][2]=0;

		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				final11[i][j] = 0;
				for (int k = 0; k < 3; k++)
				{
					final11[i][j] = final11[i][j] + rotationMatrix1[i][k] * rodaz[k][j];
				}
			}
		}



		//			std::cout << "\n rotationMatrix1==\n";
		//   for(int x=0;x<3;x++)  // loop 3 times for three lines
		//    {
		//        for(int y=0;y<3;y++)  // loop for the three elements on the line
		//        {
		//            cout<<rotationMatrix1[x][y];  // display the current element out of the array
		//        }
		//    cout<<endl;  // when the inner loop is done, go to a new line
		//    }

		//    			std::cout << "\n rodazzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz==\n";
		//   for(int x=0;x<3;x++)  // loop 3 times for three lines
		//    {
		//        for(int y=0;y<3;y++)  // loop for the three elements on the line
		//        {
		//            cout<<rodaz[x][y];  // display the current element out of the array
		//        }
		//    cout<<endl;  // when the inner loop is done, go to a new line
		//    }



		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				final22[i][j] = 0;
				for (int k = 0; k < 3; k++)
				{
					final22[i][j] = final22[i][j] + final11[i][k] * rodax[k][j];
				}
			}
		}
		//std::cout << "\n fiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii==\n";
		//   for(int x=0;x<3;x++)  // loop 3 times for three lines
		//    {
		//        for(int y=0;y<3;y++)  // loop for the three elements on the line
		//        {
		//            cout<<final22[x][y];  // display the current element out of the array
		//        }
		//    cout<<endl;  // when the inner loop is done, go to a new line
		//    }

		//**************************************************
		// Passagem de STD para EIGEN
		//**************************************************
		Final << final22[0][0], 		final22[0][1], 		final22[0][2], 		msgTf.transform.translation.x,
		final22[1][0],		    final22[1][1],		final22[1][2],		msgTf.transform.translation.y,
		final22[2][0],		    final22[2][1],		final22[2][2],		msgTf.transform.translation.z,
		0,						0,							0,							1;

//		std::cout << "\nFinalCamera==\n" << Final;

		InversoFinal=Final.inverse();
		

//	}//END IF
}//END funcao class

protected:
    ros::NodeHandle nh;
    ros::Subscriber sub;
    ros::Publisher pub;
    ros::Subscriber subscriber;
    ros::ServiceClient client;
    ros::Publisher pub_posicao;
};

main(int argc, char **argv)
{

    ros::init(argc, argv, "tratamento_kinect");

    cloudHandler handler;
    

    ros::spin();

    return 0;
}


